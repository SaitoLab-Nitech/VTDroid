# -*- coding: utf-8 -*-
#
#----------------------------------------------------------------
#
#    VTDroid
#    Copyright (C) 2021  Nagoya Institute of Technology, Hiroki Inayoshi
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <https://www.gnu.org/licenses/>."
#
#----------------------------------------------------------------
#

import io
import re
import os
import sys
import time
import psutil
import binascii
import datetime
import subprocess
from pprint import pprint

from .records import records
from .executed_part import executed_part
from .dataflow_tracer import dataflow_tracer
from ..user_input_sinks import user_input_sinks

from ..printer import Printer


class DynAnalysisExecutor(dataflow_tracer.DataflowTracer):
    def __init__(
        self,
        smalis,
        workspace,
        smalien_log_path,
        target_source,
        target_source_values,
        parameters
    ):
        # Redirect direction
        self.redirect_to = parameters['redirect_to']
        # Parameters for information flow analysis
        self.params_ifa = parameters['information_flow_analysis']
        # Printer for logging
        self.printer = Printer(workspace, self.redirect_to)
        # App's data generated by static bytecode instrumentation
        self.smalis = smalis
        # Path for saving extracted files and OCRed texts
        self.workspace = workspace
        # Path to app's runtime data (i.e., SmalienLog.txt)
        self.smalien_log_path = smalien_log_path
        # Load app's runtime data
        self.log_reader = None
        # Records holding app's runtime data
        self.records = records.Records()
        # Executed part of app code
        self.executed_part = executed_part.ExecutedPart(self.records, self.smalis)
        # Params for OCRing
        self.ocr_info = {
            'cmd': self.params_ifa['ocr_cmd'],
            'dst': self.workspace,
        }
        # Emulate info
        self.emulate_info = {
            'follow_goto_limit': int(self.params_ifa['follow_goto_limit']),
            'fail_count': 0,
        }
        # Taint propagation info
        self.taint_prop_info = {
            'da': {
                'num_uses': {
                    'cntr': 0,
                    'ids': [],
                },
            },
            'mo': {
                'num_uses': {
                    'R1': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'R2': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'R3': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'R4': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'R5': {
                        'cntr': 0,
                        'ids_propagated': [],
                        'ids_skipped': [],
                    },
                    'R6': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'R7': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'R8-9': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'R9-length': {
                        'cntr': 0,
                        'ids_propagated': [],
                        'ids_skipped': [],
                    },
                },
            },
            'cd': {
                'num_uses': {
                    'visible': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'invisible': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'sink': {
                        'cntr': 0,
                        'ids': [],
                    }
                },
            },
            'tc': {
                'num_uses': {
                    'visible': {
                        'cntr': 0,
                        'ids': [],
                    },
                    'invisible': {
                        'cntr': 0,
                        'ids': [],
                    },
                },
                'time_consuming_api_ivk': [],
                'tc_data': None,
            }
        }
        # Taint tag
        self.tag = {
            'strong': 2,
        }
        # user input sinks for hidden behavior detection (used for older sbi logs)
        self.user_input_sinks = user_input_sinks

        # Save app's launch time
        self.launch_time = None

        self.target_source = target_source
        self.target_source_values = target_source_values
        self.df_start = 0

        self.line_total = self.__get_file_line_total()

        self.process = psutil.Process(os.getpid())
        self.printer.print(f'{os.getpid() = }')
        self.dae_timeout = eval(self.params_ifa['timeout'])
        self.mem_limit = eval(self.params_ifa['mem_limit'])
        self.lines_limit = int(self.params_ifa['lines_limit'])
        if (self.lines_limit < 0):
            self.lines_limit = sys.maxsize
        self.printer.print('information flow analysis parameters')
        self.printer.print(f'{self.dae_timeout = }, {self.mem_limit = }, {self.lines_limit = }')

    def __get_file_line_total(self):
        output = subprocess.check_output(
            'wc -l ' + self.smalien_log_path,
            stderr=subprocess.STDOUT,
            shell=True
        )
        line_total = output.decode('utf-8').split(' ')[0]
        return int(line_total)

    def run(self):
        self.df_start = time.time()
        self.run_main()
        self.printer.print_dict_summary(self.taint_prop_info)
        self.printer.print(f'Tracing done in {time.time() - self.df_start}')
        # Free memory
        del self.log_reader
        del self.records

    def run_main(self):
        self.printer.print(f'    Datetime: {datetime.datetime.now()}')
        self.printer.print(f'    Smalien Log Line Total: {self.line_total}')
        self.log_reader = self.__read_smalien_log(self.smalien_log_path)
        arrayListString = ''
        cntr = 0
        for log in self.log_reader:
            if ((time.time() - self.df_start) > self.dae_timeout):
                self.printer.print('  DAE timeout occured')
                return
            if (self.process.memory_info().rss > self.mem_limit):
                self.printer.print(
                    f'  Memory limit exceeded by using memory of {self.process.memory_info().rss}'
                )
                return
            if (log not in ['SMALIEN_HIROKI_INAYOSHI', '[]']):
                arrayListString += log
            elif (arrayListString != ''):
                lines = self.__get_lines_in_arrayListString(arrayListString)
                arrayListString = ''
                for line in lines:
                    if (cntr >= self.lines_limit):
                        self.printer.print('  Line limit exceeded')
                        return
                    cntr += 1
                    if (cntr % 100000 == 0):
                        self.printer.print(f'  Finished: {cntr} in {time.time() - self.df_start} sec')
                        self.printer.print(f'    datetime: {datetime.datetime.now()}')
                        self.printer.print(f'    memory: {self.process.memory_info().rss}\n')
                    rec = self.__extrct_log(line)
                    self.trace(rec)

    def __get_lines_in_arrayListString(self, arrayListString):
        arrayListString = arrayListString[:-1]
        result = []
        matched_objs = re.finditer(r'\d{13}:\d+:\d+:\d+_\d+', arrayListString)
        previous = 0
        for matched_obj in matched_objs:
            if (previous != 0):
                line = arrayListString[previous:matched_obj.start() - 2]
                result.append(line)
            previous = matched_obj.start()
        if (previous != 0):
            line = arrayListString[previous:]
            result.append(line)
        return result

    def __extrct_log(self, l):
        # Fix corrupted log
        check = re.search(r'\d{13}:\d+:\d+:\d+_\d+, ', l)
        if (check is not None):
            l = check.group()[:-2]

        mtime = l.split(':')[0]
        pid = l.split(':')[1]
        tid = l.split(':')[2]
        tag = l.split(':')[3].split('\n')[0]
        var = tag.split('_')[-1] if (len(tag.split('_')) > 2) else None
        if (var is not None):
            val = l[re.search(r'\d{13}:\d+:\d+:\d+_\d+_[pvSt]\w+:', l).end():]
        else:
            val = None
        rec = {
            'pid': pid,
            'tid': tid,
            'tag': tag,
            'cid': int(tag.split('_')[0]),
            'line': int(tag.split('_')[1]),
            'var': var,
            'val': val,
            'time': mtime,
        }
        if (self.launch_time is None):
            self.launch_time = mtime
            self.printer.print_line(f'    App Launch Timestamp: {self.launch_time}')
        return rec

    def __read_smalien_log(self, log_path):
        with io.open(log_path, 'r', encoding='utf-8', errors='ignore') as f:
            for line in f:
                yield line.rstrip('\n')

